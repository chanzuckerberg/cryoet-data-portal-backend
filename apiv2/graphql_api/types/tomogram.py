"""
GraphQL type for Tomogram

Auto-generated by running 'make codegen'. Do not edit.
Make changes to the template codegen/templates/graphql_api/types/class_name.py.j2 instead.
"""

# ruff: noqa: E501 Line too long

import typing
from typing import TYPE_CHECKING, Annotated, Any, Optional, Sequence, Callable, List

import platformics.database.models as base_db
from platformics.graphql_api.core.strawberry_helpers import get_aggregate_selections, get_nested_selected_fields
import database.models as db
import strawberry
import datetime
from platformics.graphql_api.core.query_builder import get_db_rows, get_aggregate_db_rows
from validators.tomogram import TomogramCreateInputValidator
from validators.tomogram import TomogramUpdateInputValidator
from graphql_api.helpers.tomogram import TomogramGroupByOptions, build_tomogram_groupby_output
from platformics.graphql_api.core.relay_interface import EntityInterface
from graphql_api.types.tomogram_author import TomogramAuthorAggregate, format_tomogram_author_aggregate_output
from fastapi import Depends
from platformics.graphql_api.core.errors import PlatformicsError
from platformics.graphql_api.core.deps import get_authz_client, get_db_session, require_auth_principal, is_system_user
from platformics.graphql_api.core.query_input_types import (
    aggregator_map,
    orderBy,
    EnumComparators,
    DatetimeComparators,
    IntComparators,
    FloatComparators,
    StrComparators,
    UUIDComparators,
    BoolComparators,
)
from platformics.graphql_api.core.strawberry_extensions import DependencyExtension
from platformics.security.authorization import AuthzAction, AuthzClient, Principal
from sqlalchemy import inspect
from sqlalchemy.engine.row import RowMapping
from sqlalchemy.ext.asyncio import AsyncSession
from strawberry import relay
from strawberry.types import Info
from support.limit_offset import LimitOffsetClause
from typing_extensions import TypedDict
import enum
from support.enums import fiducial_alignment_status_enum, tomogram_reconstruction_method_enum, tomogram_processing_enum

E = typing.TypeVar("E")
T = typing.TypeVar("T")

if TYPE_CHECKING:
    from graphql_api.types.alignment import (
        AlignmentOrderByClause,
        AlignmentAggregateWhereClause,
        AlignmentWhereClause,
        Alignment,
    )
    from graphql_api.types.tomogram_author import (
        TomogramAuthorOrderByClause,
        TomogramAuthorAggregateWhereClause,
        TomogramAuthorWhereClause,
        TomogramAuthor,
    )
    from graphql_api.types.deposition import (
        DepositionOrderByClause,
        DepositionAggregateWhereClause,
        DepositionWhereClause,
        Deposition,
    )
    from graphql_api.types.run import RunOrderByClause, RunAggregateWhereClause, RunWhereClause, Run
    from graphql_api.types.tomogram_voxel_spacing import (
        TomogramVoxelSpacingOrderByClause,
        TomogramVoxelSpacingAggregateWhereClause,
        TomogramVoxelSpacingWhereClause,
        TomogramVoxelSpacing,
    )

    pass
else:
    AlignmentWhereClause = "AlignmentWhereClause"
    AlignmentAggregateWhereClause = "AlignmentAggregateWhereClause"
    Alignment = "Alignment"
    AlignmentOrderByClause = "AlignmentOrderByClause"
    TomogramAuthorWhereClause = "TomogramAuthorWhereClause"
    TomogramAuthorAggregateWhereClause = "TomogramAuthorAggregateWhereClause"
    TomogramAuthor = "TomogramAuthor"
    TomogramAuthorOrderByClause = "TomogramAuthorOrderByClause"
    DepositionWhereClause = "DepositionWhereClause"
    DepositionAggregateWhereClause = "DepositionAggregateWhereClause"
    Deposition = "Deposition"
    DepositionOrderByClause = "DepositionOrderByClause"
    RunWhereClause = "RunWhereClause"
    RunAggregateWhereClause = "RunAggregateWhereClause"
    Run = "Run"
    RunOrderByClause = "RunOrderByClause"
    TomogramVoxelSpacingWhereClause = "TomogramVoxelSpacingWhereClause"
    TomogramVoxelSpacingAggregateWhereClause = "TomogramVoxelSpacingAggregateWhereClause"
    TomogramVoxelSpacing = "TomogramVoxelSpacing"
    TomogramVoxelSpacingOrderByClause = "TomogramVoxelSpacingOrderByClause"
    pass


"""
------------------------------------------------------------------------------
Dataloaders
------------------------------------------------------------------------------
These are batching functions for loading related objects to avoid N+1 queries.
"""


@strawberry.field
async def load_alignment_rows(
    root: "Tomogram",
    info: Info,
    where: Annotated["AlignmentWhereClause", strawberry.lazy("graphql_api.types.alignment")] | None = None,
    order_by: Optional[list[Annotated["AlignmentOrderByClause", strawberry.lazy("graphql_api.types.alignment")]]] = [],
) -> Optional[Annotated["Alignment", strawberry.lazy("graphql_api.types.alignment")]]:
    dataloader = info.context["sqlalchemy_loader"]
    mapper = inspect(db.Tomogram)
    relationship = mapper.relationships["alignment"]
    return await dataloader.loader_for(relationship, where, order_by).load(root.alignment_id)  # type:ignore


@relay.connection(
    relay.ListConnection[Annotated["TomogramAuthor", strawberry.lazy("graphql_api.types.tomogram_author")]]  # type:ignore
)
async def load_tomogram_author_rows(
    root: "Tomogram",
    info: Info,
    where: Annotated["TomogramAuthorWhereClause", strawberry.lazy("graphql_api.types.tomogram_author")] | None = None,
    order_by: Optional[
        list[Annotated["TomogramAuthorOrderByClause", strawberry.lazy("graphql_api.types.tomogram_author")]]
    ] = [],
) -> Sequence[Annotated["TomogramAuthor", strawberry.lazy("graphql_api.types.tomogram_author")]]:
    dataloader = info.context["sqlalchemy_loader"]
    mapper = inspect(db.Tomogram)
    relationship = mapper.relationships["authors"]
    return await dataloader.loader_for(relationship, where, order_by).load(root.id)  # type:ignore


@strawberry.field
async def load_tomogram_author_aggregate_rows(
    root: "Tomogram",
    info: Info,
    where: Annotated["TomogramAuthorWhereClause", strawberry.lazy("graphql_api.types.tomogram_author")] | None = None,
) -> Optional[Annotated["TomogramAuthorAggregate", strawberry.lazy("graphql_api.types.tomogram_author")]]:
    selections = get_nested_selected_fields(info.selected_fields)
    dataloader = info.context["sqlalchemy_loader"]
    mapper = inspect(db.Tomogram)
    relationship = mapper.relationships["authors"]
    rows = await dataloader.aggregate_loader_for(relationship, where, selections).load(root.id)  # type:ignore
    aggregate_output = format_tomogram_author_aggregate_output(rows)
    return aggregate_output


@strawberry.field
async def load_deposition_rows(
    root: "Tomogram",
    info: Info,
    where: Annotated["DepositionWhereClause", strawberry.lazy("graphql_api.types.deposition")] | None = None,
    order_by: Optional[
        list[Annotated["DepositionOrderByClause", strawberry.lazy("graphql_api.types.deposition")]]
    ] = [],
) -> Optional[Annotated["Deposition", strawberry.lazy("graphql_api.types.deposition")]]:
    dataloader = info.context["sqlalchemy_loader"]
    mapper = inspect(db.Tomogram)
    relationship = mapper.relationships["deposition"]
    return await dataloader.loader_for(relationship, where, order_by).load(root.deposition_id)  # type:ignore


@strawberry.field
async def load_run_rows(
    root: "Tomogram",
    info: Info,
    where: Annotated["RunWhereClause", strawberry.lazy("graphql_api.types.run")] | None = None,
    order_by: Optional[list[Annotated["RunOrderByClause", strawberry.lazy("graphql_api.types.run")]]] = [],
) -> Optional[Annotated["Run", strawberry.lazy("graphql_api.types.run")]]:
    dataloader = info.context["sqlalchemy_loader"]
    mapper = inspect(db.Tomogram)
    relationship = mapper.relationships["run"]
    return await dataloader.loader_for(relationship, where, order_by).load(root.run_id)  # type:ignore


@strawberry.field
async def load_tomogram_voxel_spacing_rows(
    root: "Tomogram",
    info: Info,
    where: (
        Annotated["TomogramVoxelSpacingWhereClause", strawberry.lazy("graphql_api.types.tomogram_voxel_spacing")] | None
    ) = None,
    order_by: Optional[
        list[
            Annotated["TomogramVoxelSpacingOrderByClause", strawberry.lazy("graphql_api.types.tomogram_voxel_spacing")]
        ]
    ] = [],
) -> Optional[Annotated["TomogramVoxelSpacing", strawberry.lazy("graphql_api.types.tomogram_voxel_spacing")]]:
    dataloader = info.context["sqlalchemy_loader"]
    mapper = inspect(db.Tomogram)
    relationship = mapper.relationships["tomogram_voxel_spacing"]
    return await dataloader.loader_for(relationship, where, order_by).load(root.tomogram_voxel_spacing_id)  # type:ignore


"""
------------------------------------------------------------------------------
Define Strawberry GQL types
------------------------------------------------------------------------------
"""


"""
Only let users specify IDs in WHERE clause when mutating data (for safety).
We can extend that list as we gather more use cases from the FE team.
"""


@strawberry.input
class TomogramWhereClauseMutations(TypedDict):
    id: IntComparators | None


"""
Supported WHERE clause attributes
"""


@strawberry.input
class TomogramWhereClause(TypedDict):
    alignment: Optional[Annotated["AlignmentWhereClause", strawberry.lazy("graphql_api.types.alignment")]] | None
    alignment_id: Optional[IntComparators] | None
    authors: (
        Optional[Annotated["TomogramAuthorWhereClause", strawberry.lazy("graphql_api.types.tomogram_author")]] | None
    )
    authors_aggregate: (
        Optional[Annotated["TomogramAuthorAggregateWhereClause", strawberry.lazy("graphql_api.types.tomogram_author")]]
        | None
    )
    deposition: Optional[Annotated["DepositionWhereClause", strawberry.lazy("graphql_api.types.deposition")]] | None
    deposition_id: Optional[IntComparators] | None
    run: Optional[Annotated["RunWhereClause", strawberry.lazy("graphql_api.types.run")]] | None
    run_id: Optional[IntComparators] | None
    tomogram_voxel_spacing: (
        Optional[
            Annotated["TomogramVoxelSpacingWhereClause", strawberry.lazy("graphql_api.types.tomogram_voxel_spacing")]
        ]
        | None
    )
    tomogram_voxel_spacing_id: Optional[IntComparators] | None
    name: Optional[StrComparators] | None
    size_x: Optional[IntComparators] | None
    size_y: Optional[IntComparators] | None
    size_z: Optional[IntComparators] | None
    voxel_spacing: Optional[FloatComparators] | None
    fiducial_alignment_status: Optional[EnumComparators[fiducial_alignment_status_enum]] | None
    reconstruction_method: Optional[EnumComparators[tomogram_reconstruction_method_enum]] | None
    processing: Optional[EnumComparators[tomogram_processing_enum]] | None
    tomogram_version: Optional[FloatComparators] | None
    processing_software: Optional[StrComparators] | None
    reconstruction_software: Optional[StrComparators] | None
    is_portal_standard: Optional[BoolComparators] | None
    is_author_submitted: Optional[BoolComparators] | None
    is_visualization_default: Optional[BoolComparators] | None
    s3_omezarr_dir: Optional[StrComparators] | None
    https_omezarr_dir: Optional[StrComparators] | None
    file_size_omezarr: Optional[FloatComparators] | None
    s3_mrc_file: Optional[StrComparators] | None
    https_mrc_file: Optional[StrComparators] | None
    file_size_mrc: Optional[FloatComparators] | None
    scale0_dimensions: Optional[StrComparators] | None
    scale1_dimensions: Optional[StrComparators] | None
    scale2_dimensions: Optional[StrComparators] | None
    ctf_corrected: Optional[BoolComparators] | None
    offset_x: Optional[IntComparators] | None
    offset_y: Optional[IntComparators] | None
    offset_z: Optional[IntComparators] | None
    key_photo_url: Optional[StrComparators] | None
    key_photo_thumbnail_url: Optional[StrComparators] | None
    neuroglancer_config: Optional[StrComparators] | None
    publications: Optional[StrComparators] | None
    related_database_entries: Optional[StrComparators] | None
    id: Optional[IntComparators] | None
    deposition_date: Optional[DatetimeComparators] | None
    release_date: Optional[DatetimeComparators] | None
    last_modified_date: Optional[DatetimeComparators] | None


"""
Supported ORDER BY clause attributes
"""


@strawberry.input
class TomogramOrderByClause(TypedDict):
    alignment: Optional[Annotated["AlignmentOrderByClause", strawberry.lazy("graphql_api.types.alignment")]] | None
    deposition: Optional[Annotated["DepositionOrderByClause", strawberry.lazy("graphql_api.types.deposition")]] | None
    run: Optional[Annotated["RunOrderByClause", strawberry.lazy("graphql_api.types.run")]] | None
    tomogram_voxel_spacing: (
        Optional[
            Annotated["TomogramVoxelSpacingOrderByClause", strawberry.lazy("graphql_api.types.tomogram_voxel_spacing")]
        ]
        | None
    )
    name: Optional[orderBy] | None
    size_x: Optional[orderBy] | None
    size_y: Optional[orderBy] | None
    size_z: Optional[orderBy] | None
    voxel_spacing: Optional[orderBy] | None
    fiducial_alignment_status: Optional[orderBy] | None
    reconstruction_method: Optional[orderBy] | None
    processing: Optional[orderBy] | None
    tomogram_version: Optional[orderBy] | None
    processing_software: Optional[orderBy] | None
    reconstruction_software: Optional[orderBy] | None
    is_portal_standard: Optional[orderBy] | None
    is_author_submitted: Optional[orderBy] | None
    is_visualization_default: Optional[orderBy] | None
    s3_omezarr_dir: Optional[orderBy] | None
    https_omezarr_dir: Optional[orderBy] | None
    file_size_omezarr: Optional[orderBy] | None
    s3_mrc_file: Optional[orderBy] | None
    https_mrc_file: Optional[orderBy] | None
    file_size_mrc: Optional[orderBy] | None
    scale0_dimensions: Optional[orderBy] | None
    scale1_dimensions: Optional[orderBy] | None
    scale2_dimensions: Optional[orderBy] | None
    ctf_corrected: Optional[orderBy] | None
    offset_x: Optional[orderBy] | None
    offset_y: Optional[orderBy] | None
    offset_z: Optional[orderBy] | None
    key_photo_url: Optional[orderBy] | None
    key_photo_thumbnail_url: Optional[orderBy] | None
    neuroglancer_config: Optional[orderBy] | None
    publications: Optional[orderBy] | None
    related_database_entries: Optional[orderBy] | None
    id: Optional[orderBy] | None
    deposition_date: Optional[orderBy] | None
    release_date: Optional[orderBy] | None
    last_modified_date: Optional[orderBy] | None


"""
Define Tomogram type
"""


@strawberry.type(description="Metadata describing a tomogram.")
class Tomogram(EntityInterface):
    alignment: Optional[Annotated["Alignment", strawberry.lazy("graphql_api.types.alignment")]] = load_alignment_rows  # type:ignore
    alignment_id: Optional[int]
    authors: Sequence[Annotated["TomogramAuthor", strawberry.lazy("graphql_api.types.tomogram_author")]] = (
        load_tomogram_author_rows  # type:ignore
    )
    authors_aggregate: Optional[
        Annotated["TomogramAuthorAggregate", strawberry.lazy("graphql_api.types.tomogram_author")]
    ] = load_tomogram_author_aggregate_rows  # type:ignore
    deposition: Optional[Annotated["Deposition", strawberry.lazy("graphql_api.types.deposition")]] = (
        load_deposition_rows  # type:ignore
    )
    deposition_id: int
    run: Optional[Annotated["Run", strawberry.lazy("graphql_api.types.run")]] = load_run_rows  # type:ignore
    run_id: Optional[int]
    tomogram_voxel_spacing: Optional[
        Annotated["TomogramVoxelSpacing", strawberry.lazy("graphql_api.types.tomogram_voxel_spacing")]
    ] = load_tomogram_voxel_spacing_rows  # type:ignore
    tomogram_voxel_spacing_id: Optional[int]
    name: Optional[str] = strawberry.field(description="Short name for this tomogram", default=None)
    size_x: int = strawberry.field(description="Number of pixels in the 3D data fast axis")
    size_y: int = strawberry.field(description="Number of pixels in the 3D data medium axis")
    size_z: int = strawberry.field(
        description="Number of pixels in the 3D data slow axis.  This is the image projection direction at zero stage tilt"
    )
    voxel_spacing: float = strawberry.field(description="Voxel spacing equal in all three axes in angstroms")
    fiducial_alignment_status: fiducial_alignment_status_enum = strawberry.field(
        description="Fiducial Alignment status: True = aligned with fiducial False = aligned without fiducial"
    )
    reconstruction_method: tomogram_reconstruction_method_enum = strawberry.field(
        description="Describe reconstruction method (WBP, SART, SIRT)"
    )
    processing: tomogram_processing_enum = strawberry.field(
        description="Describe additional processing used to derive the tomogram"
    )
    tomogram_version: Optional[float] = strawberry.field(description="Version of tomogram", default=None)
    processing_software: Optional[str] = strawberry.field(
        description="Processing software used to derive the tomogram", default=None
    )
    reconstruction_software: str = strawberry.field(description="Name of software used for reconstruction")
    is_portal_standard: Optional[bool] = strawberry.field(
        description="whether this tomogram adheres to portal standards", default=None
    )
    is_author_submitted: Optional[bool] = strawberry.field(
        description="Whether this tomogram was submitted by the author of the dataset it belongs to.", default=None
    )
    is_visualization_default: Optional[bool] = strawberry.field(
        description="Data curator’s subjective choice of default tomogram to display in visualization for a run",
        default=None,
    )
    s3_omezarr_dir: Optional[str] = strawberry.field(
        description="S3 path to this tomogram in multiscale OME-Zarr format", default=None
    )
    https_omezarr_dir: Optional[str] = strawberry.field(
        description="HTTPS path to this tomogram in multiscale OME-Zarr format", default=None
    )
    file_size_omezarr: Optional[float] = strawberry.field(
        description="Size of the tomogram in OME-Zarr format in bytes", default=None
    )
    s3_mrc_file: Optional[str] = strawberry.field(
        description="S3 path to this tomogram in MRC format (no scaling)", default=None
    )
    https_mrc_file: Optional[str] = strawberry.field(
        description="HTTPS path to this tomogram in MRC format (no scaling)", default=None
    )
    file_size_mrc: Optional[float] = strawberry.field(
        description="Size of the tomogram in MRC format in bytes", default=None
    )
    scale0_dimensions: Optional[str] = strawberry.field(
        description="comma separated x,y,z dimensions of the unscaled tomogram", default=None
    )
    scale1_dimensions: Optional[str] = strawberry.field(
        description="comma separated x,y,z dimensions of the scale1 tomogram", default=None
    )
    scale2_dimensions: Optional[str] = strawberry.field(
        description="comma separated x,y,z dimensions of the scale2 tomogram", default=None
    )
    ctf_corrected: Optional[bool] = strawberry.field(description="Whether this tomogram is CTF corrected", default=None)
    offset_x: int = strawberry.field(description="x offset data relative to the canonical tomogram in pixels")
    offset_y: int = strawberry.field(description="y offset data relative to the canonical tomogram in pixels")
    offset_z: int = strawberry.field(description="z offset data relative to the canonical tomogram in pixels")
    key_photo_url: Optional[str] = strawberry.field(description="URL for the key photo", default=None)
    key_photo_thumbnail_url: Optional[str] = strawberry.field(
        description="URL for the thumbnail of key photo", default=None
    )
    neuroglancer_config: Optional[str] = strawberry.field(
        description="the compact json of neuroglancer config", default=None
    )
    publications: Optional[str] = strawberry.field(
        description="Comma-separated list of DOIs for publications associated with the tomogram.", default=None
    )
    related_database_entries: Optional[str] = strawberry.field(
        description="If a CryoET tomogram is also deposited into another database, enter the database identifier here (e.g. EMPIAR-11445). Use a comma to separate multiple identifiers.",
        default=None,
    )
    id: int = strawberry.field(description="Numeric identifier (May change!)")
    deposition_date: Optional[datetime.datetime] = strawberry.field(
        description="The date a data item was received by the cryoET data portal.", default=None
    )
    release_date: Optional[datetime.datetime] = strawberry.field(
        description="The date a data item was received by the cryoET data portal.", default=None
    )
    last_modified_date: Optional[datetime.datetime] = strawberry.field(
        description="The date a piece of data was last modified on the cryoET data portal.", default=None
    )


"""
We need to add this to each Queryable type so that strawberry will accept either our
Strawberry type *or* a SQLAlchemy model instance as a valid response class from a resolver
"""
Tomogram.__strawberry_definition__.is_type_of = (  # type: ignore
    lambda obj, info: type(obj) == db.Tomogram or type(obj) == Tomogram
)

"""
------------------------------------------------------------------------------
Aggregation types
------------------------------------------------------------------------------
"""
"""
Define columns that support numerical aggregations
"""


@strawberry.type
class TomogramNumericalColumns:
    size_x: Optional[int] = None
    size_y: Optional[int] = None
    size_z: Optional[int] = None
    voxel_spacing: Optional[float] = None
    tomogram_version: Optional[float] = None
    file_size_omezarr: Optional[float] = None
    file_size_mrc: Optional[float] = None
    offset_x: Optional[int] = None
    offset_y: Optional[int] = None
    offset_z: Optional[int] = None
    id: Optional[int] = None


"""
Define columns that support min/max aggregations
"""


@strawberry.type
class TomogramMinMaxColumns:
    name: Optional[str] = None
    size_x: Optional[int] = None
    size_y: Optional[int] = None
    size_z: Optional[int] = None
    voxel_spacing: Optional[float] = None
    tomogram_version: Optional[float] = None
    processing_software: Optional[str] = None
    reconstruction_software: Optional[str] = None
    s3_omezarr_dir: Optional[str] = None
    https_omezarr_dir: Optional[str] = None
    file_size_omezarr: Optional[float] = None
    s3_mrc_file: Optional[str] = None
    https_mrc_file: Optional[str] = None
    file_size_mrc: Optional[float] = None
    scale0_dimensions: Optional[str] = None
    scale1_dimensions: Optional[str] = None
    scale2_dimensions: Optional[str] = None
    offset_x: Optional[int] = None
    offset_y: Optional[int] = None
    offset_z: Optional[int] = None
    key_photo_url: Optional[str] = None
    key_photo_thumbnail_url: Optional[str] = None
    neuroglancer_config: Optional[str] = None
    publications: Optional[str] = None
    related_database_entries: Optional[str] = None
    id: Optional[int] = None
    deposition_date: Optional[datetime.datetime] = None
    release_date: Optional[datetime.datetime] = None
    last_modified_date: Optional[datetime.datetime] = None


"""
Define enum of all columns to support count and count(distinct) aggregations
"""


@strawberry.enum
class TomogramCountColumns(enum.Enum):
    name = "name"
    sizeX = "size_x"
    sizeY = "size_y"
    sizeZ = "size_z"
    voxelSpacing = "voxel_spacing"
    fiducialAlignmentStatus = "fiducial_alignment_status"
    reconstructionMethod = "reconstruction_method"
    processing = "processing"
    tomogramVersion = "tomogram_version"
    processingSoftware = "processing_software"
    reconstructionSoftware = "reconstruction_software"
    isPortalStandard = "is_portal_standard"
    isAuthorSubmitted = "is_author_submitted"
    isVisualizationDefault = "is_visualization_default"
    s3OmezarrDir = "s3_omezarr_dir"
    httpsOmezarrDir = "https_omezarr_dir"
    fileSizeOmezarr = "file_size_omezarr"
    s3MrcFile = "s3_mrc_file"
    httpsMrcFile = "https_mrc_file"
    fileSizeMrc = "file_size_mrc"
    scale0Dimensions = "scale0_dimensions"
    scale1Dimensions = "scale1_dimensions"
    scale2Dimensions = "scale2_dimensions"
    ctfCorrected = "ctf_corrected"
    offsetX = "offset_x"
    offsetY = "offset_y"
    offsetZ = "offset_z"
    keyPhotoUrl = "key_photo_url"
    keyPhotoThumbnailUrl = "key_photo_thumbnail_url"
    neuroglancerConfig = "neuroglancer_config"
    publications = "publications"
    relatedDatabaseEntries = "related_database_entries"
    id = "id"
    depositionDate = "deposition_date"
    releaseDate = "release_date"
    lastModifiedDate = "last_modified_date"


"""
Support *filtering* on aggregates and related aggregates
"""


@strawberry.input
class TomogramAggregateWhereClauseCount(TypedDict):
    arguments: Optional["TomogramCountColumns"] | None
    distinct: Optional[bool] | None
    filter: Optional[TomogramWhereClause] | None
    predicate: Optional[IntComparators] | None


@strawberry.input
class TomogramAggregateWhereClause(TypedDict):
    count: TomogramAggregateWhereClauseCount


"""
All supported aggregation functions
"""


@strawberry.type
class TomogramAggregateFunctions:
    # This is a hack to accept "distinct" and "columns" as arguments to "count"
    @strawberry.field
    def count(self, distinct: Optional[bool] = False, columns: Optional[TomogramCountColumns] = None) -> Optional[int]:
        # Count gets set with the proper value in the resolver, so we just return it here
        return self.count  # type: ignore

    sum: Optional[TomogramNumericalColumns] = None
    avg: Optional[TomogramNumericalColumns] = None
    stddev: Optional[TomogramNumericalColumns] = None
    variance: Optional[TomogramNumericalColumns] = None
    min: Optional[TomogramMinMaxColumns] = None
    max: Optional[TomogramMinMaxColumns] = None
    groupBy: Optional[TomogramGroupByOptions] = None


"""
Wrapper around TomogramAggregateFunctions
"""


@strawberry.type
class TomogramAggregate:
    aggregate: Optional[list[TomogramAggregateFunctions]] = None


"""
------------------------------------------------------------------------------
Mutation types
------------------------------------------------------------------------------
"""


@strawberry.input()
class TomogramCreateInput:
    alignment_id: Optional[strawberry.ID] = strawberry.field(description="Tiltseries Alignment", default=None)
    deposition_id: strawberry.ID = strawberry.field(
        description="If the tomogram is part of a deposition, the related deposition"
    )
    run_id: Optional[strawberry.ID] = strawberry.field(description=None, default=None)
    tomogram_voxel_spacing_id: Optional[strawberry.ID] = strawberry.field(
        description="Voxel spacings for a run", default=None
    )
    name: Optional[str] = strawberry.field(description="Short name for this tomogram", default=None)
    size_x: int = strawberry.field(description="Number of pixels in the 3D data fast axis")
    size_y: int = strawberry.field(description="Number of pixels in the 3D data medium axis")
    size_z: int = strawberry.field(
        description="Number of pixels in the 3D data slow axis.  This is the image projection direction at zero stage tilt"
    )
    voxel_spacing: float = strawberry.field(description="Voxel spacing equal in all three axes in angstroms")
    fiducial_alignment_status: fiducial_alignment_status_enum = strawberry.field(
        description="Fiducial Alignment status: True = aligned with fiducial False = aligned without fiducial"
    )
    reconstruction_method: tomogram_reconstruction_method_enum = strawberry.field(
        description="Describe reconstruction method (WBP, SART, SIRT)"
    )
    processing: tomogram_processing_enum = strawberry.field(
        description="Describe additional processing used to derive the tomogram"
    )
    tomogram_version: Optional[float] = strawberry.field(description="Version of tomogram", default=None)
    processing_software: Optional[str] = strawberry.field(
        description="Processing software used to derive the tomogram", default=None
    )
    reconstruction_software: str = strawberry.field(description="Name of software used for reconstruction")
    is_portal_standard: Optional[bool] = strawberry.field(
        description="whether this tomogram adheres to portal standards", default=None
    )
    is_author_submitted: Optional[bool] = strawberry.field(
        description="Whether this tomogram was submitted by the author of the dataset it belongs to.", default=None
    )
    is_visualization_default: Optional[bool] = strawberry.field(
        description="Data curator’s subjective choice of default tomogram to display in visualization for a run",
        default=None,
    )
    s3_omezarr_dir: Optional[str] = strawberry.field(
        description="S3 path to this tomogram in multiscale OME-Zarr format", default=None
    )
    https_omezarr_dir: Optional[str] = strawberry.field(
        description="HTTPS path to this tomogram in multiscale OME-Zarr format", default=None
    )
    file_size_omezarr: Optional[float] = strawberry.field(
        description="Size of the tomogram in OME-Zarr format in bytes", default=None
    )
    s3_mrc_file: Optional[str] = strawberry.field(
        description="S3 path to this tomogram in MRC format (no scaling)", default=None
    )
    https_mrc_file: Optional[str] = strawberry.field(
        description="HTTPS path to this tomogram in MRC format (no scaling)", default=None
    )
    file_size_mrc: Optional[float] = strawberry.field(
        description="Size of the tomogram in MRC format in bytes", default=None
    )
    scale0_dimensions: Optional[str] = strawberry.field(
        description="comma separated x,y,z dimensions of the unscaled tomogram", default=None
    )
    scale1_dimensions: Optional[str] = strawberry.field(
        description="comma separated x,y,z dimensions of the scale1 tomogram", default=None
    )
    scale2_dimensions: Optional[str] = strawberry.field(
        description="comma separated x,y,z dimensions of the scale2 tomogram", default=None
    )
    ctf_corrected: Optional[bool] = strawberry.field(description="Whether this tomogram is CTF corrected", default=None)
    offset_x: int = strawberry.field(description="x offset data relative to the canonical tomogram in pixels")
    offset_y: int = strawberry.field(description="y offset data relative to the canonical tomogram in pixels")
    offset_z: int = strawberry.field(description="z offset data relative to the canonical tomogram in pixels")
    key_photo_url: Optional[str] = strawberry.field(description="URL for the key photo", default=None)
    key_photo_thumbnail_url: Optional[str] = strawberry.field(
        description="URL for the thumbnail of key photo", default=None
    )
    neuroglancer_config: Optional[str] = strawberry.field(
        description="the compact json of neuroglancer config", default=None
    )
    publications: Optional[str] = strawberry.field(
        description="Comma-separated list of DOIs for publications associated with the tomogram.", default=None
    )
    related_database_entries: Optional[str] = strawberry.field(
        description="If a CryoET tomogram is also deposited into another database, enter the database identifier here (e.g. EMPIAR-11445). Use a comma to separate multiple identifiers.",
        default=None,
    )
    id: int = strawberry.field(description="Numeric identifier (May change!)")
    deposition_date: Optional[datetime.datetime] = strawberry.field(
        description="The date a data item was received by the cryoET data portal.", default=None
    )
    release_date: Optional[datetime.datetime] = strawberry.field(
        description="The date a data item was received by the cryoET data portal.", default=None
    )
    last_modified_date: Optional[datetime.datetime] = strawberry.field(
        description="The date a piece of data was last modified on the cryoET data portal.", default=None
    )


@strawberry.input()
class TomogramUpdateInput:
    alignment_id: Optional[strawberry.ID] = strawberry.field(description="Tiltseries Alignment", default=None)
    deposition_id: Optional[strawberry.ID] = strawberry.field(
        description="If the tomogram is part of a deposition, the related deposition"
    )
    run_id: Optional[strawberry.ID] = strawberry.field(description=None, default=None)
    tomogram_voxel_spacing_id: Optional[strawberry.ID] = strawberry.field(
        description="Voxel spacings for a run", default=None
    )
    name: Optional[str] = strawberry.field(description="Short name for this tomogram", default=None)
    size_x: Optional[int] = strawberry.field(description="Number of pixels in the 3D data fast axis")
    size_y: Optional[int] = strawberry.field(description="Number of pixels in the 3D data medium axis")
    size_z: Optional[int] = strawberry.field(
        description="Number of pixels in the 3D data slow axis.  This is the image projection direction at zero stage tilt"
    )
    voxel_spacing: Optional[float] = strawberry.field(description="Voxel spacing equal in all three axes in angstroms")
    fiducial_alignment_status: Optional[fiducial_alignment_status_enum] = strawberry.field(
        description="Fiducial Alignment status: True = aligned with fiducial False = aligned without fiducial"
    )
    reconstruction_method: Optional[tomogram_reconstruction_method_enum] = strawberry.field(
        description="Describe reconstruction method (WBP, SART, SIRT)"
    )
    processing: Optional[tomogram_processing_enum] = strawberry.field(
        description="Describe additional processing used to derive the tomogram"
    )
    tomogram_version: Optional[float] = strawberry.field(description="Version of tomogram", default=None)
    processing_software: Optional[str] = strawberry.field(
        description="Processing software used to derive the tomogram", default=None
    )
    reconstruction_software: Optional[str] = strawberry.field(description="Name of software used for reconstruction")
    is_portal_standard: Optional[bool] = strawberry.field(
        description="whether this tomogram adheres to portal standards", default=None
    )
    is_author_submitted: Optional[bool] = strawberry.field(
        description="Whether this tomogram was submitted by the author of the dataset it belongs to.", default=None
    )
    is_visualization_default: Optional[bool] = strawberry.field(
        description="Data curator’s subjective choice of default tomogram to display in visualization for a run",
        default=None,
    )
    s3_omezarr_dir: Optional[str] = strawberry.field(
        description="S3 path to this tomogram in multiscale OME-Zarr format", default=None
    )
    https_omezarr_dir: Optional[str] = strawberry.field(
        description="HTTPS path to this tomogram in multiscale OME-Zarr format", default=None
    )
    file_size_omezarr: Optional[float] = strawberry.field(
        description="Size of the tomogram in OME-Zarr format in bytes", default=None
    )
    s3_mrc_file: Optional[str] = strawberry.field(
        description="S3 path to this tomogram in MRC format (no scaling)", default=None
    )
    https_mrc_file: Optional[str] = strawberry.field(
        description="HTTPS path to this tomogram in MRC format (no scaling)", default=None
    )
    file_size_mrc: Optional[float] = strawberry.field(
        description="Size of the tomogram in MRC format in bytes", default=None
    )
    scale0_dimensions: Optional[str] = strawberry.field(
        description="comma separated x,y,z dimensions of the unscaled tomogram", default=None
    )
    scale1_dimensions: Optional[str] = strawberry.field(
        description="comma separated x,y,z dimensions of the scale1 tomogram", default=None
    )
    scale2_dimensions: Optional[str] = strawberry.field(
        description="comma separated x,y,z dimensions of the scale2 tomogram", default=None
    )
    ctf_corrected: Optional[bool] = strawberry.field(description="Whether this tomogram is CTF corrected", default=None)
    offset_x: Optional[int] = strawberry.field(description="x offset data relative to the canonical tomogram in pixels")
    offset_y: Optional[int] = strawberry.field(description="y offset data relative to the canonical tomogram in pixels")
    offset_z: Optional[int] = strawberry.field(description="z offset data relative to the canonical tomogram in pixels")
    key_photo_url: Optional[str] = strawberry.field(description="URL for the key photo", default=None)
    key_photo_thumbnail_url: Optional[str] = strawberry.field(
        description="URL for the thumbnail of key photo", default=None
    )
    neuroglancer_config: Optional[str] = strawberry.field(
        description="the compact json of neuroglancer config", default=None
    )
    publications: Optional[str] = strawberry.field(
        description="Comma-separated list of DOIs for publications associated with the tomogram.", default=None
    )
    related_database_entries: Optional[str] = strawberry.field(
        description="If a CryoET tomogram is also deposited into another database, enter the database identifier here (e.g. EMPIAR-11445). Use a comma to separate multiple identifiers.",
        default=None,
    )
    id: Optional[int] = strawberry.field(description="Numeric identifier (May change!)")
    deposition_date: Optional[datetime.datetime] = strawberry.field(
        description="The date a data item was received by the cryoET data portal.", default=None
    )
    release_date: Optional[datetime.datetime] = strawberry.field(
        description="The date a data item was received by the cryoET data portal.", default=None
    )
    last_modified_date: Optional[datetime.datetime] = strawberry.field(
        description="The date a piece of data was last modified on the cryoET data portal.", default=None
    )


"""
------------------------------------------------------------------------------
Utilities
------------------------------------------------------------------------------
"""


@strawberry.field(extensions=[DependencyExtension()])
async def resolve_tomograms(
    session: AsyncSession = Depends(get_db_session, use_cache=False),
    authz_client: AuthzClient = Depends(get_authz_client),
    principal: Principal = Depends(require_auth_principal),
    where: Optional[TomogramWhereClause] = None,
    order_by: Optional[list[TomogramOrderByClause]] = [],
    limit_offset: Optional[LimitOffsetClause] = None,
) -> typing.Sequence[Tomogram]:
    """
    Resolve Tomogram objects. Used for queries (see graphql_api/queries.py).
    """
    limit = limit_offset["limit"] if limit_offset and "limit" in limit_offset else None
    offset = limit_offset["offset"] if limit_offset and "offset" in limit_offset else None
    if offset and not limit:
        raise PlatformicsError("Cannot use offset without limit")
    return await get_db_rows(
        db.Tomogram, session, authz_client, principal, where, order_by, AuthzAction.VIEW, limit, offset
    )  # type: ignore


def format_tomogram_aggregate_output(query_results: Sequence[RowMapping] | RowMapping) -> TomogramAggregate:
    """
    Given a row from the DB containing the results of an aggregate query,
    format the results using the proper GraphQL types.
    """
    aggregate = []
    if not type(query_results) is list:
        query_results = [query_results]  # type: ignore
    for row in query_results:
        aggregate.append(format_tomogram_aggregate_row(row))
    return TomogramAggregate(aggregate=aggregate)


def format_tomogram_aggregate_row(row: RowMapping) -> TomogramAggregateFunctions:
    """
    Given a single row from the DB containing the results of an aggregate query,
    format the results using the proper GraphQL types.
    """
    output = TomogramAggregateFunctions()
    for key, value in row.items():
        # Key is either an aggregate function or a groupby key
        group_keys = key.split(".")
        aggregate = key.split("_", 1)
        if aggregate[0] not in aggregator_map.keys():
            # Turn list of groupby keys into nested objects
            if not getattr(output, "groupBy"):
                setattr(output, "groupBy", TomogramGroupByOptions())
            group = build_tomogram_groupby_output(getattr(output, "groupBy"), group_keys, value)
            setattr(output, "groupBy", group)
        else:
            aggregate_name = aggregate[0]
            if aggregate_name == "count":
                output.count = value
            else:
                aggregator_fn, col_name = aggregate[0], aggregate[1]
                if not getattr(output, aggregator_fn):
                    if aggregate_name in ["min", "max"]:
                        setattr(output, aggregator_fn, TomogramMinMaxColumns())
                    else:
                        setattr(output, aggregator_fn, TomogramNumericalColumns())
                setattr(getattr(output, aggregator_fn), col_name, value)
    return output


@strawberry.field(extensions=[DependencyExtension()])
async def resolve_tomograms_aggregate(
    info: Info,
    session: AsyncSession = Depends(get_db_session, use_cache=False),
    authz_client: AuthzClient = Depends(get_authz_client),
    principal: Principal = Depends(require_auth_principal),
    where: Optional[TomogramWhereClause] = None,
    # TODO: add support for groupby, limit/offset
) -> TomogramAggregate:
    """
    Aggregate values for Tomogram objects. Used for queries (see graphql_api/queries.py).
    """
    # Get the selected aggregate functions and columns to operate on, and groupby options if any were provided.
    # TODO: not sure why selected_fields is a list
    aggregate_selections, groupby_selections = get_aggregate_selections(info.selected_fields)

    if not aggregate_selections:
        raise PlatformicsError("No aggregate functions selected")

    rows = await get_aggregate_db_rows(
        db.Tomogram, session, authz_client, principal, where, aggregate_selections, [], groupby_selections
    )  # type: ignore
    aggregate_output = format_tomogram_aggregate_output(rows)
    return aggregate_output


@strawberry.mutation(extensions=[DependencyExtension()])
async def create_tomogram(
    input: TomogramCreateInput,
    session: AsyncSession = Depends(get_db_session, use_cache=False),
    authz_client: AuthzClient = Depends(get_authz_client),
    principal: Principal = Depends(require_auth_principal),
    is_system_user: bool = Depends(is_system_user),
) -> db.Tomogram:
    """
    Create a new Tomogram object. Used for mutations (see graphql_api/mutations.py).
    """
    validated = TomogramCreateInputValidator(**input.__dict__)
    params = validated.model_dump()

    # Validate that the user can read all of the entities they're linking to.

    # Validate that the user can read all of the entities they're linking to.
    # Check that alignment relationship is accessible.
    if validated.alignment_id:
        alignment = await get_db_rows(
            db.Alignment,
            session,
            authz_client,
            principal,
            {"id": {"_eq": validated.alignment_id}},
            [],
            AuthzAction.VIEW,
        )
        if not alignment:
            raise PlatformicsError("Unauthorized: alignment does not exist")
    # Check that deposition relationship is accessible.
    if validated.deposition_id:
        deposition = await get_db_rows(
            db.Deposition,
            session,
            authz_client,
            principal,
            {"id": {"_eq": validated.deposition_id}},
            [],
            AuthzAction.VIEW,
        )
        if not deposition:
            raise PlatformicsError("Unauthorized: deposition does not exist")
    # Check that run relationship is accessible.
    if validated.run_id:
        run = await get_db_rows(
            db.Run, session, authz_client, principal, {"id": {"_eq": validated.run_id}}, [], AuthzAction.VIEW
        )
        if not run:
            raise PlatformicsError("Unauthorized: run does not exist")
    # Check that tomogram_voxel_spacing relationship is accessible.
    if validated.tomogram_voxel_spacing_id:
        tomogram_voxel_spacing = await get_db_rows(
            db.TomogramVoxelSpacing,
            session,
            authz_client,
            principal,
            {"id": {"_eq": validated.tomogram_voxel_spacing_id}},
            [],
            AuthzAction.VIEW,
        )
        if not tomogram_voxel_spacing:
            raise PlatformicsError("Unauthorized: tomogram_voxel_spacing does not exist")

    # Save to DB
    params["owner_user_id"] = int(principal.id)
    new_entity = db.Tomogram(**params)

    # Are we actually allowed to create this entity?
    if not authz_client.can_create(new_entity, principal):
        raise PlatformicsError("Unauthorized: Cannot create entity")

    session.add(new_entity)
    await session.commit()
    return new_entity


@strawberry.mutation(extensions=[DependencyExtension()])
async def update_tomogram(
    input: TomogramUpdateInput,
    where: TomogramWhereClauseMutations,
    session: AsyncSession = Depends(get_db_session, use_cache=False),
    authz_client: AuthzClient = Depends(get_authz_client),
    principal: Principal = Depends(require_auth_principal),
    is_system_user: bool = Depends(is_system_user),
) -> Sequence[db.Tomogram]:
    """
    Update Tomogram objects. Used for mutations (see graphql_api/mutations.py).
    """
    validated = TomogramUpdateInputValidator(**input.__dict__)
    params = validated.model_dump()

    # Need at least one thing to update
    num_params = len([x for x in params if params[x] is not None])
    if num_params == 0:
        raise PlatformicsError("No fields to update")

    # Validate that the user can read all of the entities they're linking to.
    # Check that alignment relationship is accessible.
    if validated.alignment_id:
        alignment = await get_db_rows(
            db.Alignment,
            session,
            authz_client,
            principal,
            {"id": {"_eq": validated.alignment_id}},
            [],
            AuthzAction.VIEW,
        )
        if not alignment:
            raise PlatformicsError("Unauthorized: alignment does not exist")
        params["alignment"] = alignment[0]
        del params["alignment_id"]
    # Check that deposition relationship is accessible.
    if validated.deposition_id:
        deposition = await get_db_rows(
            db.Deposition,
            session,
            authz_client,
            principal,
            {"id": {"_eq": validated.deposition_id}},
            [],
            AuthzAction.VIEW,
        )
        if not deposition:
            raise PlatformicsError("Unauthorized: deposition does not exist")
        params["deposition"] = deposition[0]
        del params["deposition_id"]
    # Check that run relationship is accessible.
    if validated.run_id:
        run = await get_db_rows(
            db.Run, session, authz_client, principal, {"id": {"_eq": validated.run_id}}, [], AuthzAction.VIEW
        )
        if not run:
            raise PlatformicsError("Unauthorized: run does not exist")
        params["run"] = run[0]
        del params["run_id"]
    # Check that tomogram_voxel_spacing relationship is accessible.
    if validated.tomogram_voxel_spacing_id:
        tomogram_voxel_spacing = await get_db_rows(
            db.TomogramVoxelSpacing,
            session,
            authz_client,
            principal,
            {"id": {"_eq": validated.tomogram_voxel_spacing_id}},
            [],
            AuthzAction.VIEW,
        )
        if not tomogram_voxel_spacing:
            raise PlatformicsError("Unauthorized: tomogram_voxel_spacing does not exist")
        params["tomogram_voxel_spacing"] = tomogram_voxel_spacing[0]
        del params["tomogram_voxel_spacing_id"]

    # Fetch entities for update, if we have access to them
    entities = await get_db_rows(db.Tomogram, session, authz_client, principal, where, [], AuthzAction.UPDATE)
    if len(entities) == 0:
        raise PlatformicsError("Unauthorized: Cannot update entities")

    # Update DB
    updated_at = datetime.datetime.now()
    for entity in entities:
        entity.updated_at = updated_at
        for key in params:
            if params[key] is not None:
                setattr(entity, key, params[key])

    if not authz_client.can_update(entity, principal):
        raise PlatformicsError("Unauthorized: Cannot access new collection")

    await session.commit()
    return entities


@strawberry.mutation(extensions=[DependencyExtension()])
async def delete_tomogram(
    where: TomogramWhereClauseMutations,
    session: AsyncSession = Depends(get_db_session, use_cache=False),
    authz_client: AuthzClient = Depends(get_authz_client),
    principal: Principal = Depends(require_auth_principal),
) -> Sequence[db.Tomogram]:
    """
    Delete Tomogram objects. Used for mutations (see graphql_api/mutations.py).
    """
    # Fetch entities for deletion, if we have access to them
    entities = await get_db_rows(db.Tomogram, session, authz_client, principal, where, [], AuthzAction.DELETE)
    if len(entities) == 0:
        raise PlatformicsError("Unauthorized: Cannot delete entities")

    # Update DB
    for entity in entities:
        await session.delete(entity)
    await session.commit()
    return entities
